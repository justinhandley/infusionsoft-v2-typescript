/* tslint:disable */
/* eslint-disable */
/**
 * Keap REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.70.0.655384-hf-202403291416
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { RestHook } from '../models';
import { RestHookRequest } from '../models';
/**
 * RESTHooksApi - axios parameter creator
 * @export
 */
export const RESTHooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To receive hooks, you'll first need to subscribe to events one at a time *and* individually verify each subscription.  This operation is used to create hook subscriptions. During this process, Infusionsoft will attempt to verify your subscription. Continue reading to learn how that works.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Create a Hook Subscription
         * @param {RestHookRequest} body restHookRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAHookSubscription: async (body: RestHookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAHookSubscription.');
            }
            const localVarPath = `/v1/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop receiving hooks by deleting an existing hook subscription.
         * @summary Delete a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAHookSubscription: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteAHookSubscription.');
            }
            const localVarPath = `/v1/hooks/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List the available types of Events that can be listened to
         * @summary List Hook Event Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHookEventTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hooks/event_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists your hook subscriptions.
         * @summary List Stored Hook Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStoredHookSubscriptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an existing hook subscription and its status.  If your hook subscription becomes inactive, you may request an activation attempt via [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription).
         * @summary Retrieve a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAHookSubscription: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling retrieveAHookSubscription.');
            }
            const localVarPath = `/v1/hooks/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing hook subscription using the provided values.
         * @summary Update a Hook Subscription
         * @param {RestHookRequest} body restHookRequest
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAHookSubscription: async (body: RestHookRequest, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAHookSubscription.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateAHookSubscription.');
            }
            const localVarPath = `/v1/hooks/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation is used to verify or reactivate a hook subscription using RESTHooks.org's [Immediate Confirmation](http://resthooks.org/docs/security/) pattern.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Verify a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAHookSubscription: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling verifyAHookSubscription.');
            }
            const localVarPath = `/v1/hooks/{key}/verify`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation is used to verify or reactivate a hook subscription out-of-band using RESTHooks.org's [Delayed Confirmation](http://resthooks.org/docs/security/) pattern.  Use this verification method if you're not able to use the Immediate Confirmation provided through [Create a Hook Subscription](#!/REST_Hooks/create_a_hook_subscription) or [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription). This operation allows you to confirm a subscription by manually sending us the `X-Hook-Secret` you received.  NB: **The `X-Hook-Secret` _must_ be passed as a _header_.**  Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Verify a Hook Subscription, Delayed
         * @param {string} xHookSecret X-Hook-Secret
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAHookSubscriptionDelayed: async (xHookSecret: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xHookSecret' is not null or undefined
            if (xHookSecret === null || xHookSecret === undefined) {
                throw new RequiredError('xHookSecret','Required parameter xHookSecret was null or undefined when calling verifyAHookSubscriptionDelayed.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling verifyAHookSubscriptionDelayed.');
            }
            const localVarPath = `/v1/hooks/{key}/delayedVerify`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xHookSecret !== undefined && xHookSecret !== null) {
                localVarHeaderParameter['X-Hook-Secret'] = String(xHookSecret);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RESTHooksApi - functional programming interface
 * @export
 */
export const RESTHooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * To receive hooks, you'll first need to subscribe to events one at a time *and* individually verify each subscription.  This operation is used to create hook subscriptions. During this process, Infusionsoft will attempt to verify your subscription. Continue reading to learn how that works.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Create a Hook Subscription
         * @param {RestHookRequest} body restHookRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAHookSubscription(body: RestHookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RestHook>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).createAHookSubscription(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Stop receiving hooks by deleting an existing hook subscription.
         * @summary Delete a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAHookSubscription(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).deleteAHookSubscription(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the available types of Events that can be listened to
         * @summary List Hook Event Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHookEventTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<string>>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).listHookEventTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists your hook subscriptions.
         * @summary List Stored Hook Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStoredHookSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<RestHook>>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).listStoredHookSubscriptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves an existing hook subscription and its status.  If your hook subscription becomes inactive, you may request an activation attempt via [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription).
         * @summary Retrieve a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAHookSubscription(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RestHook>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).retrieveAHookSubscription(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modify an existing hook subscription using the provided values.
         * @summary Update a Hook Subscription
         * @param {RestHookRequest} body restHookRequest
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAHookSubscription(body: RestHookRequest, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RestHook>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).updateAHookSubscription(body, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This operation is used to verify or reactivate a hook subscription using RESTHooks.org's [Immediate Confirmation](http://resthooks.org/docs/security/) pattern.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Verify a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAHookSubscription(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RestHook>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).verifyAHookSubscription(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This operation is used to verify or reactivate a hook subscription out-of-band using RESTHooks.org's [Delayed Confirmation](http://resthooks.org/docs/security/) pattern.  Use this verification method if you're not able to use the Immediate Confirmation provided through [Create a Hook Subscription](#!/REST_Hooks/create_a_hook_subscription) or [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription). This operation allows you to confirm a subscription by manually sending us the `X-Hook-Secret` you received.  NB: **The `X-Hook-Secret` _must_ be passed as a _header_.**  Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Verify a Hook Subscription, Delayed
         * @param {string} xHookSecret X-Hook-Secret
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAHookSubscriptionDelayed(xHookSecret: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RestHook>>> {
            const localVarAxiosArgs = await RESTHooksApiAxiosParamCreator(configuration).verifyAHookSubscriptionDelayed(xHookSecret, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RESTHooksApi - factory interface
 * @export
 */
export const RESTHooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * To receive hooks, you'll first need to subscribe to events one at a time *and* individually verify each subscription.  This operation is used to create hook subscriptions. During this process, Infusionsoft will attempt to verify your subscription. Continue reading to learn how that works.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Create a Hook Subscription
         * @param {RestHookRequest} body restHookRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAHookSubscription(body: RestHookRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<RestHook>> {
            return RESTHooksApiFp(configuration).createAHookSubscription(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop receiving hooks by deleting an existing hook subscription.
         * @summary Delete a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAHookSubscription(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return RESTHooksApiFp(configuration).deleteAHookSubscription(key, options).then((request) => request(axios, basePath));
        },
        /**
         * List the available types of Events that can be listened to
         * @summary List Hook Event Types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHookEventTypes(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<string>>> {
            return RESTHooksApiFp(configuration).listHookEventTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists your hook subscriptions.
         * @summary List Stored Hook Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStoredHookSubscriptions(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<RestHook>>> {
            return RESTHooksApiFp(configuration).listStoredHookSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an existing hook subscription and its status.  If your hook subscription becomes inactive, you may request an activation attempt via [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription).
         * @summary Retrieve a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAHookSubscription(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RestHook>> {
            return RESTHooksApiFp(configuration).retrieveAHookSubscription(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing hook subscription using the provided values.
         * @summary Update a Hook Subscription
         * @param {RestHookRequest} body restHookRequest
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAHookSubscription(body: RestHookRequest, key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RestHook>> {
            return RESTHooksApiFp(configuration).updateAHookSubscription(body, key, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation is used to verify or reactivate a hook subscription using RESTHooks.org's [Immediate Confirmation](http://resthooks.org/docs/security/) pattern.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Verify a Hook Subscription
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAHookSubscription(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RestHook>> {
            return RESTHooksApiFp(configuration).verifyAHookSubscription(key, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation is used to verify or reactivate a hook subscription out-of-band using RESTHooks.org's [Delayed Confirmation](http://resthooks.org/docs/security/) pattern.  Use this verification method if you're not able to use the Immediate Confirmation provided through [Create a Hook Subscription](#!/REST_Hooks/create_a_hook_subscription) or [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription). This operation allows you to confirm a subscription by manually sending us the `X-Hook-Secret` you received.  NB: **The `X-Hook-Secret` _must_ be passed as a _header_.**  Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
         * @summary Verify a Hook Subscription, Delayed
         * @param {string} xHookSecret X-Hook-Secret
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAHookSubscriptionDelayed(xHookSecret: string, key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RestHook>> {
            return RESTHooksApiFp(configuration).verifyAHookSubscriptionDelayed(xHookSecret, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RESTHooksApi - object-oriented interface
 * @export
 * @class RESTHooksApi
 * @extends {BaseAPI}
 */
export class RESTHooksApi extends BaseAPI {
    /**
     * To receive hooks, you'll first need to subscribe to events one at a time *and* individually verify each subscription.  This operation is used to create hook subscriptions. During this process, Infusionsoft will attempt to verify your subscription. Continue reading to learn how that works.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
     * @summary Create a Hook Subscription
     * @param {RestHookRequest} body restHookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async createAHookSubscription(body: RestHookRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<RestHook>> {
        return RESTHooksApiFp(this.configuration).createAHookSubscription(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Stop receiving hooks by deleting an existing hook subscription.
     * @summary Delete a Hook Subscription
     * @param {string} key key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async deleteAHookSubscription(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return RESTHooksApiFp(this.configuration).deleteAHookSubscription(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the available types of Events that can be listened to
     * @summary List Hook Event Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async listHookEventTypes(options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<string>>> {
        return RESTHooksApiFp(this.configuration).listHookEventTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists your hook subscriptions.
     * @summary List Stored Hook Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async listStoredHookSubscriptions(options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<RestHook>>> {
        return RESTHooksApiFp(this.configuration).listStoredHookSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves an existing hook subscription and its status.  If your hook subscription becomes inactive, you may request an activation attempt via [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription).
     * @summary Retrieve a Hook Subscription
     * @param {string} key key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async retrieveAHookSubscription(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RestHook>> {
        return RESTHooksApiFp(this.configuration).retrieveAHookSubscription(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Modify an existing hook subscription using the provided values.
     * @summary Update a Hook Subscription
     * @param {RestHookRequest} body restHookRequest
     * @param {string} key key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async updateAHookSubscription(body: RestHookRequest, key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RestHook>> {
        return RESTHooksApiFp(this.configuration).updateAHookSubscription(body, key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This operation is used to verify or reactivate a hook subscription using RESTHooks.org's [Immediate Confirmation](http://resthooks.org/docs/security/) pattern.  To verify or reactivate a hook subscription, Infusionsoft will make a `POST` request with a temporary secret to the `hookUrl` you provided during creation. The secret is passed as the value of a header named `X-Hook-Secret`. Your response to that `POST` *must* have a status code of `200` and return the same `X-Hook-Secret` header and value pair. Once you've done that, you'll begin receiving hooks. Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
     * @summary Verify a Hook Subscription
     * @param {string} key key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async verifyAHookSubscription(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RestHook>> {
        return RESTHooksApiFp(this.configuration).verifyAHookSubscription(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This operation is used to verify or reactivate a hook subscription out-of-band using RESTHooks.org's [Delayed Confirmation](http://resthooks.org/docs/security/) pattern.  Use this verification method if you're not able to use the Immediate Confirmation provided through [Create a Hook Subscription](#!/REST_Hooks/create_a_hook_subscription) or [Verify a Hook Subscription](#!/REST_Hooks/verify_a_hook_subscription). This operation allows you to confirm a subscription by manually sending us the `X-Hook-Secret` you received.  NB: **The `X-Hook-Secret` _must_ be passed as a _header_.**  Don't worry if verification fails; you can always [request another verification attempt](#!/REST_Hooks/verify_a_hook_subscription).  NB: You will not receive events until the subscription is verified.  If the verification process seems confusing, head over to [RESTHooks.org](http://resthooks.org/docs/security/) for more on the concept.
     * @summary Verify a Hook Subscription, Delayed
     * @param {string} xHookSecret X-Hook-Secret
     * @param {string} key key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTHooksApi
     */
    public async verifyAHookSubscriptionDelayed(xHookSecret: string, key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RestHook>> {
        return RESTHooksApiFp(this.configuration).verifyAHookSubscriptionDelayed(xHookSecret, key, options).then((request) => request(this.axios, this.basePath));
    }
}
